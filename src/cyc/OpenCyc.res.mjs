// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var defaultEndpoint = "http://localhost:3602";

var $$default = {
  endpoint: defaultEndpoint,
  timeout: 5000
};

var Config = {
  defaultEndpoint: defaultEndpoint,
  connectionTimeout: 5000,
  $$default: $$default
};

var Concepts = {
  humanLanguage: "#$HumanLanguage",
  writingScript: "#$WritingScript",
  geographicalRegion: "#$GeographicalRegion",
  linguisticProperty: "#$LinguisticProperty",
  languageFamily: "#$LanguageFamily",
  spokenIn: "#$languageSpokenInRegion",
  writtenIn: "#$languageWrittenInScript",
  subLanguageOf: "#$subLanguageOf",
  wordOrder: "#$WordOrder",
  phonologicalInventory: "#$PhonologicalInventory",
  morphologicalType: "#$MorphologicalType"
};

var Types = {};

function resultError(x) {
  return {
          TAG: "Error",
          _0: x
        };
}

function make(endpoint, timeout, param) {
  return {
          config: {
            endpoint: Core__Option.getOr(endpoint, defaultEndpoint),
            timeout: Core__Option.getOr(timeout, 5000)
          },
          state: "Disconnected"
        };
}

function connect(_client) {
  return Promise.resolve({
              TAG: "Error",
              _0: "OpenCyc connection not implemented"
            });
}

function disconnect(client) {
  client.state = "Disconnected";
}

function isConnected(client) {
  var match = client.state;
  if (typeof match !== "object" && match === "Connected") {
    return true;
  } else {
    return false;
  }
}

var Client = {
  resultError: resultError,
  make: make,
  connect: connect,
  disconnect: disconnect,
  isConnected: isConnected
};

function languageQuery(iso639_3) {
  return "(#$isa ?lang #$HumanLanguage)\n     (#$iso639-3Code ?lang \"" + iso639_3 + "\")";
}

function languagesInRegion(region) {
  return "(#$isa ?lang #$HumanLanguage)\n     (#$languageSpokenInRegion ?lang " + region + ")";
}

function languagesWithScript(script) {
  return "(#$isa ?lang #$HumanLanguage)\n     (#$languageWrittenInScript ?lang " + script + ")";
}

function languageFamilyQuery(language) {
  return "(#$subLanguageOf " + language + " ?family)";
}

function execute(_client, _query) {
  return Promise.resolve({
              TAG: "Failure",
              _0: "Query execution not implemented"
            });
}

var Query = {
  languageQuery: languageQuery,
  languagesInRegion: languagesInRegion,
  languagesWithScript: languagesWithScript,
  languageFamilyQuery: languageFamilyQuery,
  execute: execute
};

var d = {};

d["eng"] = "#$English-HumanLanguage";

d["deu"] = "#$German-HumanLanguage";

d["fra"] = "#$French-HumanLanguage";

d["spa"] = "#$Spanish-HumanLanguage";

d["por"] = "#$Portuguese-HumanLanguage";

d["ita"] = "#$Italian-HumanLanguage";

d["rus"] = "#$Russian-HumanLanguage";

d["zho"] = "#$Chinese-HumanLanguage";

d["jpn"] = "#$Japanese-HumanLanguage";

d["kor"] = "#$Korean-HumanLanguage";

d["ara"] = "#$Arabic-HumanLanguage";

d["heb"] = "#$Hebrew-HumanLanguage";

d["ell"] = "#$Greek-HumanLanguage";

d["lat"] = "#$Latin-HumanLanguage";

d["san"] = "#$Sanskrit-HumanLanguage";

var d$1 = {};

d$1["indo-european"] = "#$IndoEuropeanLanguageFamily";

d$1["sino-tibetan"] = "#$SinoTibetanLanguageFamily";

d$1["afroasiatic"] = "#$AfroAsiaticLanguageFamily";

d$1["austronesian"] = "#$AustronesianLanguageFamily";

d$1["niger-congo"] = "#$NigerCongoLanguageFamily";

d$1["dravidian"] = "#$DravidianLanguageFamily";

d$1["uralic"] = "#$UralicLanguageFamily";

d$1["altaic"] = "#$AltaicLanguageFamily";

var d$2 = {};

d$2["latin"] = "#$LatinAlphabet";

d$2["cyrillic"] = "#$CyrillicAlphabet";

d$2["greek"] = "#$GreekAlphabet";

d$2["arabic"] = "#$ArabicScript";

d$2["hebrew"] = "#$HebrewAlphabet";

d$2["devanagari"] = "#$DevanagariScript";

d$2["chinese"] = "#$ChineseCharacters";

d$2["japanese"] = "#$JapaneseWritingSystem";

d$2["korean"] = "#$HangulAlphabet";

function getCycConstant(iso639_3) {
  return d[iso639_3];
}

function getLanguageFamily(familyName) {
  return d$1[familyName.toLowerCase()];
}

function getScript(scriptName) {
  return d$2[scriptName.toLowerCase()];
}

var LanguageOntology = {
  iso639ToCyc: d,
  languageFamilies: d$1,
  writingScripts: d$2,
  getCycConstant: getCycConstant,
  getLanguageFamily: getLanguageFamily,
  getScript: getScript
};

function isInFamily(_client, _language, _family) {
  return Promise.resolve(false);
}

function languagesInRegion$1(_client, _region) {
  return Promise.resolve([]);
}

function relatedLanguages(_client, _language) {
  return Promise.resolve([]);
}

function scriptsCompatible(_script1, _script2) {
  return false;
}

var Reasoning = {
  isInFamily: isInFamily,
  languagesInRegion: languagesInRegion$1,
  relatedLanguages: relatedLanguages,
  scriptsCompatible: scriptsCompatible
};

function syncLanguages(_client, _languages) {
  return Promise.resolve(0);
}

function updateMappings(_client) {
  return Promise.resolve({
              TAG: "Error",
              _0: "Not implemented"
            });
}

var Sync = {
  syncLanguages: syncLanguages,
  updateMappings: updateMappings
};

export {
  Config ,
  Concepts ,
  Types ,
  Client ,
  Query ,
  LanguageOntology ,
  Reasoning ,
  Sync ,
}
/*  Not a pure module */
