// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var Types = {};

var defaultUserAgent = "1000Langs/0.1.0 (Parallel Corpus Crawler; +https://github.com/Hyperpolymath/1000Langs)";

function makeDefaultHeaders() {
  var headers = {};
  headers["User-Agent"] = defaultUserAgent;
  headers["Accept"] = "text/html,application/xhtml+xml,application/xml";
  headers["Accept-Language"] = "en-US,en;q=0.9";
  return headers;
}

var Config = {
  defaultTimeout: 30000,
  defaultRetries: 3,
  defaultUserAgent: defaultUserAgent,
  defaultRateLimitMs: 1000,
  makeDefaultHeaders: makeDefaultHeaders
};

function make(url, methodOpt, headers, timeout, retries, param) {
  var method = methodOpt !== undefined ? methodOpt : "GET";
  return {
          url: url,
          method: method,
          headers: Core__Option.getOr(headers, makeDefaultHeaders()),
          timeout: Core__Option.getOr(timeout, 30000),
          retries: Core__Option.getOr(retries, 3)
        };
}

function withHeader(config, key, value) {
  config.headers[key] = value;
  return config;
}

function methodToString(method) {
  switch (method) {
    case "GET" :
        return "GET";
    case "POST" :
        return "POST";
    case "HEAD" :
        return "HEAD";
    
  }
}

var $$Request = {
  make: make,
  withHeader: withHeader,
  methodToString: methodToString
};

function make$1(delayMsOpt, param) {
  var delayMs = delayMsOpt !== undefined ? delayMsOpt : 1000;
  return {
          lastRequest: 0.0,
          delayMs: delayMs
        };
}

function canProceed(limiter) {
  var now = Date.now();
  var elapsed = now - limiter.lastRequest;
  return elapsed >= limiter.delayMs;
}

function recordRequest(limiter) {
  limiter.lastRequest = Date.now();
}

var RateLimiter = {
  make: make$1,
  canProceed: canProceed,
  recordRequest: recordRequest
};

function calculateDelay(strategy, attempt) {
  switch (strategy.TAG) {
    case "Constant" :
        return strategy._0;
    case "Linear" :
        return Math.imul(strategy._0, attempt);
    case "Exponential" :
        return strategy._0 * Math.pow(strategy._1, attempt - 1 | 0) | 0;
    
  }
}

var shouldRetry = Caml_obj.lessthan;

var RetryPolicy = {
  calculateDelay: calculateDelay,
  shouldRetry: shouldRetry
};

function selectorToString(selector) {
  switch (selector.TAG) {
    case "Css" :
        return "css:" + selector._0;
    case "XPath" :
        return "xpath:" + selector._0;
    case "Regex" :
        return "regex:" + selector._0;
    
  }
}

var Parser = {
  selectorToString: selectorToString
};

export {
  Types ,
  Config ,
  $$Request ,
  RateLimiter ,
  RetryPolicy ,
  Parser ,
}
/* No side effect */
