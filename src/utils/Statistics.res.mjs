// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";

var Types = {};

function sum(arr) {
  return Core__Array.reduce(arr, 0.0, (function (acc, x) {
                return acc + x;
              }));
}

function mean(arr) {
  var len = arr.length;
  if (len === 0) {
    return 0.0;
  } else {
    return sum(arr) / len;
  }
}

function variance(arr) {
  var len = arr.length;
  if (len === 0) {
    return 0.0;
  }
  var m = mean(arr);
  var squaredDiffs = arr.map(function (x) {
        var diff = x - m;
        return diff * diff;
      });
  return sum(squaredDiffs) / len;
}

function standardDeviation(arr) {
  return Math.sqrt(variance(arr));
}

function min(arr) {
  return Core__Array.reduce(arr, undefined, (function (acc, x) {
                if (acc !== undefined) {
                  return x < acc ? x : acc;
                } else {
                  return x;
                }
              }));
}

function max(arr) {
  return Core__Array.reduce(arr, undefined, (function (acc, x) {
                if (acc !== undefined) {
                  return x > acc ? x : acc;
                } else {
                  return x;
                }
              }));
}

var Basic = {
  sum: sum,
  mean: mean,
  variance: variance,
  standardDeviation: standardDeviation,
  min: min,
  max: max
};

function entropy(dist) {
  return Core__Array.reduce(dist, 0.0, (function (acc, p) {
                if (p > 1e-10) {
                  return acc - p * Math.log2(p);
                } else {
                  return acc;
                }
              }));
}

function klDivergence(p, q) {
  if (p.length !== q.length) {
    return NaN;
  }
  var result = 0.0;
  for(var i = 0 ,i_finish = p.length; i < i_finish; ++i){
    var pi = p[i];
    var qi = q[i];
    if (pi > 1e-10 && qi > 1e-10) {
      result = result + pi * Math.log2(pi / qi);
    }
    
  }
  return result;
}

function symmetricKL(p, q) {
  return (klDivergence(p, q) + klDivergence(q, p)) / 2.0;
}

function jensenShannon(p, q) {
  if (p.length !== q.length) {
    return NaN;
  }
  var m = p.map(function (pi, i) {
        var qi = q[i];
        return (pi + qi) / 2.0;
      });
  return (klDivergence(p, m) + klDivergence(q, m)) / 2.0;
}

var Information = {
  epsilon: 1e-10,
  entropy: entropy,
  klDivergence: klDivergence,
  symmetricKL: symmetricKL,
  jensenShannon: jensenShannon
};

function euclidean(a, b) {
  if (a.length !== b.length) {
    return NaN;
  }
  var sumSq = 0.0;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    var diff = a[i] - b[i];
    sumSq = sumSq + diff * diff;
  }
  return Math.sqrt(sumSq);
}

function cosine(a, b) {
  if (a.length !== b.length) {
    return NaN;
  }
  var dot = 0.0;
  var normA = 0.0;
  var normB = 0.0;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    var ai = a[i];
    var bi = b[i];
    dot = dot + ai * bi;
    normA = normA + ai * ai;
    normB = normB + bi * bi;
  }
  var denom = Math.sqrt(normA) * Math.sqrt(normB);
  if (denom > 0.0) {
    return 1.0 - dot / denom;
  } else {
    return 0.0;
  }
}

function jaccard(a, b) {
  var intersection = 0;
  var union = 0;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    var ai = a[i] > 0.0;
    var bi = b[i] > 0.0;
    if (ai && bi) {
      intersection = intersection + 1 | 0;
    }
    if (ai || bi) {
      union = union + 1 | 0;
    }
    
  }
  if (union === 0) {
    return 0.0;
  } else {
    return 1.0 - intersection / union;
  }
}

function compute(metric, a, b) {
  switch (metric) {
    case "Euclidean" :
        return euclidean(a, b);
    case "Cosine" :
        return cosine(a, b);
    case "KLDivergence" :
        return symmetricKL(a, b);
    case "JensenShannon" :
        return jensenShannon(a, b);
    case "Jaccard" :
        return jaccard(a, b);
    
  }
}

var Distance = {
  euclidean: euclidean,
  cosine: cosine,
  jaccard: jaccard,
  compute: compute
};

function distanceMatrix(vectors, metric) {
  var n = vectors.length;
  var result = Core__Array.make(n, []);
  for(var i = 0; i < n; ++i){
    var row = Core__Array.make(n, 0.0);
    for(var j = 0; j < n; ++j){
      if (i === j) {
        row[j] = 0.0;
      } else if (j < i) {
        row[j] = result[j][i];
      } else {
        var vi = vectors[i];
        var vj = vectors[j];
        row[j] = compute(metric, vi, vj);
      }
    }
    result[i] = row;
  }
  return result;
}

var Matrix = {
  distanceMatrix: distanceMatrix
};

function normalize(arr) {
  var total = sum(arr);
  if (total > 0.0) {
    return arr.map(function (x) {
                return x / total;
              });
  } else {
    return arr;
  }
}

function minMaxNormalize(arr) {
  var match = min(arr);
  var match$1 = max(arr);
  if (match === undefined) {
    return arr;
  }
  if (match$1 === undefined) {
    return arr;
  }
  if (match$1 <= match) {
    return arr;
  }
  var range = match$1 - match;
  return arr.map(function (x) {
              return (x - match) / range;
            });
}

function zScoreNormalize(arr) {
  var m = mean(arr);
  var sd = Math.sqrt(variance(arr));
  if (sd > 0.0) {
    return arr.map(function (x) {
                return (x - m) / sd;
              });
  } else {
    return arr;
  }
}

var Normalization = {
  normalize: normalize,
  minMaxNormalize: minMaxNormalize,
  zScoreNormalize: zScoreNormalize
};

export {
  Types ,
  Basic ,
  Information ,
  Distance ,
  Matrix ,
  Normalization ,
}
/* No side effect */
